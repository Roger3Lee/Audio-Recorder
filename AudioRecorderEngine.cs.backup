using NAudio.Wave;
using NAudio.CoreAudioApi;
using SoundTouch;
using MathNet.Numerics;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace AudioRecorder
{
    public enum RecordingMode
    {
        Mixed,      // æ··åˆæ¨¡å¼
        Separate    // åˆ†ç¦»æ¨¡å¼
    }

    public enum AudioQuality
    {
        Standard,   // 44.1kHz, 16-bit
        High,       // 48kHz, 24-bit
        Studio      // 96kHz, 32-bit
    }

    public class AudioRecorderEngine : IDisposable
    {
        // éŸ³é¢‘è¾“å…¥è®¾å¤‡
        private WasapiLoopbackCapture? loopbackCapture;
        private WaveInEvent? waveIn;
        
        // éŸ³é¢‘è¾“å‡ºæ–‡ä»¶
        private WaveFileWriter? mixedAudioWriter;
        private WaveFileWriter? systemAudioWriter;
        private WaveFileWriter? micAudioWriter;
        
        // å½•åˆ¶çŠ¶æ€
        private bool isRecording = false;
        private string outputDirectory;
        private NAudio.Wave.WaveFormat outputFormat;
        private readonly object lockObject = new object();

        // ä¸“ä¸šéŸ³é¢‘å¤„ç†ç»„ä»¶
        private MasterAudioProcessor masterProcessor;
        private AudioMixingBus mixingBus;
        
        // é«˜æ€§èƒ½éŸ³é¢‘ç¼“å†²åŒº
        private AdvancedCircularBuffer systemBuffer;
        private AdvancedCircularBuffer micBuffer;
        
        // å½•åˆ¶é…ç½®
        private bool recordSystemAudio = true;
        private bool recordMicrophone = true;
        private RecordingMode recordingMode = RecordingMode.Mixed;
        
        // ä¼˜åŒ–çš„éŸ³é¢‘å‚æ•° - åŸºäºä¸“ä¸šå½•éŸ³æ ‡å‡†
        private float microphoneGain = 4.5f;      // æé«˜éº¦å…‹é£å¢ç›Šï¼Œç¡®ä¿æ¸…æ™°è¯­éŸ³
        private float systemAudioGain = 0.12f;    // å¤§å¹…é™ä½ç³»ç»ŸéŸ³é¢‘ï¼Œæœ€å°åŒ–å™ªéŸ³
        
        // éŸ³è´¨è®¾ç½®
        private AudioQuality audioQuality = AudioQuality.High;
        
        // ä¸“ä¸šéŸ³é¢‘å¤„ç†å‚æ•°
        private bool enableNoiseReduction = true;
        private bool enableDynamicRangeCompression = true;
        private bool enableVoiceEnhancement = true;
        private bool enableSystemAudioNoiseReduction = true;
        private bool enableSmartMixing = true;
        private bool enableSpectralGating = true;         // é¢‘è°±é—¨æ§
        private bool enableAdaptiveFiltering = true;      // è‡ªé€‚åº”æ»¤æ³¢
        
        // å¤„ç†å‚æ•°
        private float compressionThreshold = 0.65f;      // æ›´ä½çš„å‹ç¼©é˜ˆå€¼
        private float compressionRatio = 3.0f;           // æ›´é«˜çš„å‹ç¼©æ¯”
        private float voiceFreqBoost = 1.8f;             // æ›´å¼ºçš„è¯­éŸ³å¢å¼º
        private float systemAudioMaxLevel = 0.2f;        // æ›´ä¸¥æ ¼çš„ç³»ç»ŸéŸ³é¢‘é™åˆ¶
        private float intelligentBalanceRatio = 5.0f;    // æ›´æ™ºèƒ½çš„åŠ¨æ€å¹³è¡¡
        private int bufferLatency = 10;                  // è¶…ä½å»¶è¿Ÿ
        
        // åŠ¨æ€çŠ¶æ€è·Ÿè¸ª
        private float systemNoiseProfile = 0.01f;         // ç³»ç»Ÿå™ªå£°é…ç½®æ–‡ä»¶
        private float currentSystemLevel = 0f;            // å½“å‰ç³»ç»ŸéŸ³é‡
        private float currentMicLevel = 0f;               // å½“å‰éº¦å…‹é£éŸ³é‡
        private float[] systemEnvelopeBuffer = new float[100];  // ç³»ç»ŸéŸ³é¢‘åŒ…ç»œç¼“å†²
        private float[] micEnvelopeBuffer = new float[100];     // éº¦å…‹é£åŒ…ç»œç¼“å†²
        private int envelopeIndex = 0;                    // åŒ…ç»œç¼“å†²ç´¢å¼•

        public event EventHandler<string>? StatusChanged;
        public event EventHandler<Exception>? ErrorOccurred;

        public AudioRecorderEngine()
        {
            outputDirectory = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "AudioRecordings");
            Directory.CreateDirectory(outputDirectory);
            
            SetAudioQuality(audioQuality);
            InitializeProfessionalAudioSystem();
        }

        // å…¬å…±å±æ€§
        public bool IsRecording => isRecording;
        public RecordingMode Mode { get; set; } = RecordingMode.Mixed;
        
        public AudioQuality Quality 
        { 
            get => audioQuality; 
            set 
            { 
                audioQuality = value;
                SetAudioQuality(value);
            }
        }
        
        public float MicrophoneGain 
        { 
            get => microphoneGain; 
            set => microphoneGain = Math.Max(0.1f, Math.Min(8.0f, value));
        }
        
        public float SystemAudioGain 
        { 
            get => systemAudioGain; 
            set => systemAudioGain = Math.Max(0.05f, Math.Min(1.0f, value));
        }
        
        public bool EnableNoiseReduction 
        { 
            get => enableNoiseReduction; 
            set => enableNoiseReduction = value; 
        }
        
        public bool EnableDynamicRangeCompression 
        { 
            get => enableDynamicRangeCompression; 
            set => enableDynamicRangeCompression = value; 
        }
        
        public bool EnableVoiceEnhancement 
        { 
            get => enableVoiceEnhancement; 
            set => enableVoiceEnhancement = value; 
        }
        
        public bool EnableSystemAudioNoiseReduction 
        { 
            get => enableSystemAudioNoiseReduction; 
            set => enableSystemAudioNoiseReduction = value; 
        }
        
        public bool EnableSmartMixing 
        { 
            get => enableSmartMixing; 
            set => enableSmartMixing = value; 
        }
        
        public float SystemAudioMaxLevel 
        { 
            get => systemAudioMaxLevel; 
            set => systemAudioMaxLevel = Math.Max(0.1f, Math.Min(0.8f, value)); 
        }

        private void SetAudioQuality(AudioQuality quality)
        {
            outputFormat = quality switch
            {
                AudioQuality.Standard => new NAudio.Wave.WaveFormat(44100, 16, 2),
                AudioQuality.High => new NAudio.Wave.WaveFormat(48000, 24, 2),
                AudioQuality.Studio => new NAudio.Wave.WaveFormat(96000, 32, 2),
                _ => new NAudio.Wave.WaveFormat(48000, 24, 2)
            };
        }

        private void InitializeProfessionalAudioSystem()
        {
            try
            {
                // åˆå§‹åŒ–é«˜ç²¾åº¦å¾ªç¯ç¼“å†²åŒº
                int bufferSize = outputFormat.SampleRate * 10; // 10ç§’ç¼“å†²
                systemBuffer = new AdvancedCircularBuffer(bufferSize);
                micBuffer = new AdvancedCircularBuffer(bufferSize);
                
                // åˆå§‹åŒ–ä¸“ä¸šéŸ³é¢‘å¤„ç†å™¨
                masterProcessor = new MasterAudioProcessor(outputFormat.SampleRate);
                
                // åˆå§‹åŒ–æ··éŸ³æ€»çº¿
                mixingBus = new AudioMixingBus();
                
                StatusChanged?.Invoke(this, "ğŸ›ï¸ ä¸“ä¸šéŸ³é¢‘ç³»ç»Ÿå·²åˆå§‹åŒ– (Studio-Grade Processing)");
            }
            catch (Exception ex)
            {
                ErrorOccurred?.Invoke(this, new Exception("ä¸“ä¸šéŸ³é¢‘ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥", ex));
            }
        }

        public void StartRecording(bool recordSystemAudio = true, bool recordMicrophone = true, RecordingMode mode = RecordingMode.Mixed)
        {
            if (isRecording)
            {
                StatusChanged?.Invoke(this, "å½•åˆ¶å·²åœ¨è¿›è¡Œä¸­");
                return;
            }

            this.recordSystemAudio = recordSystemAudio;
            this.recordMicrophone = recordMicrophone;
            this.recordingMode = mode;

            if (!recordSystemAudio && !recordMicrophone)
            {
                StatusChanged?.Invoke(this, "è¯·è‡³å°‘é€‰æ‹©ä¸€ç§å½•åˆ¶æº");
                return;
            }

            try
            {
                string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                string qualityLabel = audioQuality.ToString();

                if (recordingMode == RecordingMode.Mixed)
                {
                    string mixedAudioPath = Path.Combine(outputDirectory, $"MixedAudio_Studio_{qualityLabel}_{timestamp}.wav");
                    mixedAudioWriter = new WaveFileWriter(mixedAudioPath, outputFormat);
                    StatusChanged?.Invoke(this, $"ğŸšï¸ å½•éŸ³å®¤çº§æ··åˆå½•åˆ¶å·²å¼€å§‹ ({GetQualityDescription()})");
                    StatusChanged?.Invoke(this, $"ğŸ’¾ ä¿å­˜åˆ°: {mixedAudioPath}");
                    
                    if (recordMicrophone)
                    {
                        StatusChanged?.Invoke(this, $"ğŸ¤ éº¦å…‹é£å·²å¯ç”¨ - å¢ç›Š: {microphoneGain:F1}x (å½•éŸ³å®¤ä¼˜åŒ–)");
                        StatusChanged?.Invoke(this, "ğŸ”‡ å¤šçº§æ™ºèƒ½é™å™ªå·²å¯ç”¨");
                        StatusChanged?.Invoke(this, "ğŸ—£ï¸ AIè¯­éŸ³å¢å¼ºå·²å¯ç”¨");
                    }
                    
                    if (recordSystemAudio)
                    {
                        StatusChanged?.Invoke(this, $"ğŸ”Š ç³»ç»ŸéŸ³é¢‘å·²å¯ç”¨ - å¢ç›Š: {systemAudioGain:F2}x (æ·±åº¦é™å™ª)");
                        StatusChanged?.Invoke(this, "âš¡ ç”µç£å¹²æ‰°æ¶ˆé™¤å·²å¯ç”¨");
                        StatusChanged?.Invoke(this, "ğŸ¯ é¢‘è°±é—¨æ§å·²å¯ç”¨");
                    }
                    
                    StatusChanged?.Invoke(this, "ğŸ§  æ™ºèƒ½è‡ªé€‚åº”æ··éŸ³å·²å¯ç”¨");
                    StatusChanged?.Invoke(this, "ğŸ“Š å®æ—¶é¢‘è°±åˆ†æå·²å¯ç”¨");
                }
                else
                {
                    if (recordSystemAudio)
                    {
                        string systemAudioPath = Path.Combine(outputDirectory, $"SystemAudio_Studio_{qualityLabel}_{timestamp}.wav");
                        systemAudioWriter = new WaveFileWriter(systemAudioPath, outputFormat);
                        StatusChanged?.Invoke(this, $"ç³»ç»ŸéŸ³é¢‘å°†ä¿å­˜åˆ°: {systemAudioPath}");
                    }

                    if (recordMicrophone)
                    {
                        string micAudioPath = Path.Combine(outputDirectory, $"Microphone_Studio_{qualityLabel}_{timestamp}.wav");
                        NAudio.Wave.WaveFormat micFormat = new NAudio.Wave.WaveFormat(outputFormat.SampleRate, outputFormat.BitsPerSample, 1);
                        micAudioWriter = new WaveFileWriter(micAudioPath, micFormat);
                        StatusChanged?.Invoke(this, $"éº¦å…‹é£éŸ³é¢‘å°†ä¿å­˜åˆ°: {micAudioPath}");
                    }
                }

                // é‡ç½®ç¼“å†²åŒºå’ŒçŠ¶æ€
                systemBuffer.Clear();
                micBuffer.Clear();
                ResetDynamicStates();

                if (recordSystemAudio)
                {
                    StartSystemAudioCapture(timestamp);
                }

                if (recordMicrophone)
                {
                    StartMicrophoneCapture(timestamp);
                }

                isRecording = true;
                string modeText = recordingMode == RecordingMode.Mixed ? "æ··åˆ" : "åˆ†ç¦»";
                StatusChanged?.Invoke(this, $"âœ… {modeText}æ¨¡å¼å½•åˆ¶å·²å¼€å§‹ (å½•éŸ³å®¤å“è´¨)");
            }
            catch (Exception ex)
            {
                ErrorOccurred?.Invoke(this, ex);
                StopRecording();
            }
        }

        private void ResetDynamicStates()
        {
            systemNoiseProfile = 0.01f;
            currentSystemLevel = 0f;
            currentMicLevel = 0f;
            Array.Clear(systemEnvelopeBuffer, 0, systemEnvelopeBuffer.Length);
            Array.Clear(micEnvelopeBuffer, 0, micEnvelopeBuffer.Length);
            envelopeIndex = 0;
            masterProcessor?.Reset();
            mixingBus?.Reset();
        }

        private string GetQualityDescription()
        {
            return audioQuality switch
            {
                AudioQuality.Standard => "44.1kHz/16bit/ç«‹ä½“å£°",
                AudioQuality.High => "48kHz/24bit/ç«‹ä½“å£°",
                AudioQuality.Studio => "96kHz/32bit/ç«‹ä½“å£°",
                _ => "48kHz/24bit/ç«‹ä½“å£°"
            };
        }

        private void StartSystemAudioCapture(string timestamp)
        {
            loopbackCapture = new WasapiLoopbackCapture();
            
            // è®¾ç½®æ›´å°çš„ç¼“å†²åŒºä»¥å‡å°‘å»¶è¿Ÿ
            loopbackCapture.ShareMode = AudioClientShareMode.Shared;

            if (recordingMode == RecordingMode.Separate)
            {
                string qualityLabel = audioQuality.ToString();
                string systemAudioPath = Path.Combine(outputDirectory, $"SystemAudio_Studio_{qualityLabel}_{timestamp}.wav");
                systemAudioWriter = new WaveFileWriter(systemAudioPath, loopbackCapture.WaveFormat);
            }
            
            loopbackCapture.DataAvailable += (sender, e) =>
            {
                if (!isRecording) return;

                try
                {
                    ProcessSystemAudioData(e.Buffer, e.BytesRecorded, loopbackCapture.WaveFormat);
                }
                catch (Exception ex)
                {
                    ErrorOccurred?.Invoke(this, ex);
                }
            };

            loopbackCapture.RecordingStopped += (sender, e) =>
            {
                if (recordingMode == RecordingMode.Separate)
                {
                    systemAudioWriter?.Dispose();
                    systemAudioWriter = null;
                }
            };

            loopbackCapture.StartRecording();
        }

        private void StartMicrophoneCapture(string timestamp)
        {
            waveIn = new WaveInEvent();
            waveIn.WaveFormat = new NAudio.Wave.WaveFormat(outputFormat.SampleRate, outputFormat.BitsPerSample, 1);
            waveIn.BufferMilliseconds = bufferLatency;
            waveIn.NumberOfBuffers = 8;  // æ›´å¤šç¼“å†²åŒºä»¥æé«˜ç¨³å®šæ€§

            waveIn.DataAvailable += (sender, e) =>
            {
                if (!isRecording) return;

                try
                {
                    ProcessMicrophoneData(e.Buffer, e.BytesRecorded, waveIn.WaveFormat);
                }
                catch (Exception ex)
                {
                    ErrorOccurred?.Invoke(this, ex);
                }
            };

            waveIn.RecordingStopped += (sender, e) =>
            {
                if (recordingMode == RecordingMode.Separate)
                {
                    micAudioWriter?.Dispose();
                    micAudioWriter = null;
                }
            };

            waveIn.StartRecording();
        }

        private void ProcessSystemAudioData(byte[] buffer, int bytesRecorded, NAudio.Wave.WaveFormat format)
        {
            if (recordingMode == RecordingMode.Mixed)
            {
                // è½¬æ¢ä¸ºæµ®ç‚¹æ•°æ®
                float[] floatData = ConvertToFloat32(buffer, bytesRecorded, format);
                
                // ä¸“ä¸šéŸ³é¢‘é¢„å¤„ç†
                floatData = masterProcessor.ProcessSystemAudioPreMix(floatData, systemAudioGain);
                
                // é‡é‡‡æ ·ï¼ˆå¦‚æœéœ€è¦ï¼‰
                if (format.SampleRate != outputFormat.SampleRate)
                {
                    floatData = ResampleAudio(floatData, format.SampleRate, outputFormat.SampleRate, format.Channels);
                }
                
                // å­˜å‚¨åˆ°ç¼“å†²åŒº
                lock (lockObject)
                {
                    systemBuffer.Write(floatData);
                    ProcessMixedAudioOutput();
                }
            }
            else
            {
                // åˆ†ç¦»æ¨¡å¼å¤„ç†
                ProcessSeparateSystemAudio(buffer, bytesRecorded, format);
            }
        }

        private void ProcessMicrophoneData(byte[] buffer, int bytesRecorded, NAudio.Wave.WaveFormat format)
        {
            if (recordingMode == RecordingMode.Mixed)
            {
                // è½¬æ¢ä¸ºæµ®ç‚¹æ•°æ®
                float[] floatData = ConvertToFloat32(buffer, bytesRecorded, format);
                
                // ä¸“ä¸šéŸ³é¢‘é¢„å¤„ç†
                floatData = masterProcessor.ProcessMicrophoneAudioPreMix(floatData, microphoneGain);
                
                // å­˜å‚¨åˆ°ç¼“å†²åŒº
                lock (lockObject)
                {
                    micBuffer.Write(floatData);
                    ProcessMixedAudioOutput();
                }
            }
            else
            {
                // åˆ†ç¦»æ¨¡å¼å¤„ç†
                ProcessSeparateMicrophoneAudio(buffer, bytesRecorded, format);
            }
        }

        private void ProcessSeparateSystemAudio(byte[] buffer, int bytesRecorded, NAudio.Wave.WaveFormat format)
        {
            if (Math.Abs(systemAudioGain - 1.0f) > 0.01f || enableSystemAudioNoiseReduction)
            {
                float[] floats = ConvertToFloat32(buffer, bytesRecorded, format);
                floats = masterProcessor.ProcessSystemAudioSeparate(floats, systemAudioGain);
                byte[] processedBytes = ConvertFromFloat32(floats, format);
                systemAudioWriter?.Write(processedBytes, 0, processedBytes.Length);
            }
            else
            {
                systemAudioWriter?.Write(buffer, 0, bytesRecorded);
            }
        }

        private void ProcessSeparateMicrophoneAudio(byte[] buffer, int bytesRecorded, NAudio.Wave.WaveFormat format)
        {
            float[] floats = ConvertToFloat32(buffer, bytesRecorded, format);
            floats = masterProcessor.ProcessMicrophoneAudioSeparate(floats, microphoneGain);
            byte[] processedBytes = ConvertFromFloat32(floats, format);
            micAudioWriter?.Write(processedBytes, 0, processedBytes.Length);
        }

        private void ProcessMixedAudioOutput()
        {
            if (mixedAudioWriter == null || recordingMode != RecordingMode.Mixed) return;

            // ä½¿ç”¨ä¸“ä¸šéŸ³é¢‘å—å¤§å°
            const int blockSize = 256; // ä½å»¶è¿Ÿä¸“ä¸šæ ‡å‡†
            
            bool hasSystemAudio = recordSystemAudio && systemBuffer.Available >= blockSize * 2;
            bool hasMicAudio = recordMicrophone && micBuffer.Available >= blockSize;

            if (!hasSystemAudio && !hasMicAudio) return;
            
            // è¯»å–æ•°æ®å¹¶è¿›è¡Œæ™ºèƒ½æ··éŸ³
            float[] systemData = new float[blockSize * 2];
            float[] micData = new float[blockSize];
            
            if (hasSystemAudio)
            {
                systemBuffer.Read(systemData, blockSize * 2);
            }
            
            if (hasMicAudio)
            {
                micBuffer.Read(micData, blockSize);
            }
            
            // ä½¿ç”¨æ–°çš„æ··éŸ³å¤„ç†å™¨
            float[] mixedOutput = masterProcessor.MixAudioChannels(
                systemData, 
                micData, 
                hasSystemAudio, 
                hasMicAudio,
                enableSmartMixing,
                enableDynamicRangeCompression);
            
            // å†™å…¥æ–‡ä»¶
            if (mixedOutput.Length > 0)
            {
                byte[] outputBytes = ConvertFromFloat32(mixedOutput, outputFormat);
                mixedAudioWriter.Write(outputBytes, 0, outputBytes.Length);
            }
        }

        private float[] ConvertToFloat32(byte[] input, int length, NAudio.Wave.WaveFormat format)
        {
            int samplesCount = length / (format.BitsPerSample / 8);
            float[] output = new float[samplesCount];

            switch (format.BitsPerSample)
            {
                case 16:
                    for (int i = 0; i < samplesCount; i++)
                    {
                        short sample = BitConverter.ToInt16(input, i * 2);
                        output[i] = sample / 32768f;
                    }
                    break;
                    
                case 24:
                    for (int i = 0; i < samplesCount; i++)
                    {
                        int sample = (input[i * 3] << 8) | (input[i * 3 + 1] << 16) | (input[i * 3 + 2] << 24);
                        output[i] = sample / (float)(1 << 31);
                    }
                    break;
                    
                case 32:
                    for (int i = 0; i < samplesCount; i++)
                    {
                        int sample = BitConverter.ToInt32(input, i * 4);
                        output[i] = sample / (float)(1L << 31);
                    }
                    break;
            }

            return output;
        }

        private float[] ResampleAudio(float[] input, int fromRate, int toRate, int channels)
        {
            if (fromRate == toRate) return input;
            
            // ä½¿ç”¨SoundTouchè¿›è¡Œé«˜è´¨é‡é‡é‡‡æ ·
            using (var soundTouch = new SoundTouchProcessor())
            {
                soundTouch.SetSampleRate(fromRate);
                soundTouch.SetChannels(channels);
                soundTouch.SetRate((float)toRate / fromRate);
                
                soundTouch.PutSamples(input);
                soundTouch.Flush();
                
                var resampled = new List<float>();
                float[] buffer = new float[2048];
                
                uint received;
                do
                {
                    received = soundTouch.ReceiveSamples(buffer, (uint)buffer.Length / (uint)channels);
                    if (received > 0)
                    {
                        resampled.AddRange(buffer.Take((int)(received * channels)));
                    }
                } while (received > 0);
                
                return resampled.ToArray();
            }
        }

        private byte[] ConvertFromFloat32(float[] input, NAudio.Wave.WaveFormat format)
        {
            byte[] output = new byte[input.Length * (format.BitsPerSample / 8)];

            switch (format.BitsPerSample)
            {
                case 16:
                    for (int i = 0; i < input.Length; i++)
                    {
                        short sample = (short)Math.Max(-32768, Math.Min(32767, input[i] * 32767f));
                        byte[] bytes = BitConverter.GetBytes(sample);
                        output[i * 2] = bytes[0];
                        output[i * 2 + 1] = bytes[1];
                    }
                    break;
                    
                case 24:
                    for (int i = 0; i < input.Length; i++)
                    {
                        int sample = (int)Math.Max(-8388608, Math.Min(8388607, input[i] * 8388607f));
                        output[i * 3] = (byte)(sample & 0xFF);
                        output[i * 3 + 1] = (byte)((sample >> 8) & 0xFF);
                        output[i * 3 + 2] = (byte)((sample >> 16) & 0xFF);
                    }
                    break;
                    
                case 32:
                    for (int i = 0; i < input.Length; i++)
                    {
                        int sample = (int)Math.Max(int.MinValue, Math.Min(int.MaxValue, input[i] * 2147483647f));
                        byte[] bytes = BitConverter.GetBytes(sample);
                        Array.Copy(bytes, 0, output, i * 4, 4);
                    }
                    break;
            }

            return output;
        }

        public void StopRecording()
        {
            if (!isRecording) return;

            isRecording = false;

            try
            {
                loopbackCapture?.StopRecording();
                loopbackCapture?.Dispose();
                loopbackCapture = null;

                waveIn?.StopRecording();
                waveIn?.Dispose();
                waveIn = null;

                mixedAudioWriter?.Dispose();
                mixedAudioWriter = null;

                systemAudioWriter?.Dispose();
                systemAudioWriter = null;

                micAudioWriter?.Dispose();
                micAudioWriter = null;

                StatusChanged?.Invoke(this, "ğŸ›‘ å½•éŸ³å®¤çº§å½•åˆ¶å·²åœæ­¢");
            }
            catch (Exception ex)
            {
                ErrorOccurred?.Invoke(this, ex);
            }
        }

        public string[] GetAvailableMicrophones()
        {
            var microphones = new List<string>();
            for (int i = 0; i < WaveIn.DeviceCount; i++)
            {
                var deviceInfo = WaveIn.GetCapabilities(i);
                microphones.Add($"{i}: {deviceInfo.ProductName}");
            }
            return microphones.ToArray();
        }

        public void SetMicrophoneDevice(int deviceIndex)
        {
            if (waveIn != null)
            {
                waveIn.DeviceNumber = deviceIndex;
            }
        }

        public void Dispose()
        {
            StopRecording();
            masterProcessor?.Dispose();
            mixingBus?.Dispose();
            systemBuffer?.Dispose();
            micBuffer?.Dispose();
        }
    }

    // ä¸“ä¸šéŸ³é¢‘å¤„ç†å™¨
    public class ProfessionalAudioProcessor : IDisposable
    {
        private readonly int sampleRate;
        private readonly SpectralGate spectralGate;
        private readonly AdaptiveFilter adaptiveFilter;
        private readonly VoiceEnhancer voiceEnhancer;
        
        public ProfessionalAudioProcessor(int sampleRate)
        {
            this.sampleRate = sampleRate;
            spectralGate = new SpectralGate(sampleRate);
            adaptiveFilter = new AdaptiveFilter();
            voiceEnhancer = new VoiceEnhancer();
        }
        
        public float[] PreProcessSystemAudio(float[] input, NAudio.Wave.WaveFormat format)
        {
            // å¤šçº§é™å™ªå¤„ç†
            float[] processed = spectralGate.Process(input);
            processed = adaptiveFilter.RemoveElectromagneticInterference(processed, format.Channels);
            return processed;
        }
        
        public float[] PreProcessMicrophoneAudio(float[] input)
        {
            // è¯­éŸ³ä¼˜åŒ–å¤„ç†
            float[] processed = voiceEnhancer.Process(input);
            return processed;
        }
        
        public float[] ProcessSystemAudioSeparate(float[] input, float gain)
        {
            float[] processed = spectralGate.Process(input);
            ApplyGain(processed, gain);
            return processed;
        }
        
        public float[] ProcessMicrophoneAudioSeparate(float[] input, float gain)
        {
            float[] processed = voiceEnhancer.Process(input);
            ApplyGain(processed, gain);
            return processed;
        }
        
        public float[] ApplyMasterProcessing(float[] input)
        {
            // ä¸»è¾“å‡ºå¤„ç†é“¾
            float[] processed = DynamicsProcessor.ApplyLimiting(input, 0.95f);
            return processed;
        }
        
        public float[] Resample(float[] input, int fromRate, int toRate, int channels)
        {
            if (fromRate == toRate) return input;
            
            // é«˜è´¨é‡é‡é‡‡æ ·ç®—æ³•
            return HighQualityResampler.Resample(input, fromRate, toRate, channels);
        }
        
        private void ApplyGain(float[] samples, float gain)
        {
            for (int i = 0; i < samples.Length; i++)
            {
                samples[i] *= gain;
            }
        }
        
        public void Reset()
        {
            spectralGate.Reset();
            adaptiveFilter.Reset();
            voiceEnhancer.Reset();
        }
        
        public void Dispose()
        {
            // æ¸…ç†èµ„æº
        }
    }

    // é«˜æ€§èƒ½ç¯å½¢ç¼“å†²åŒº
    public class RingBuffer : IDisposable
    {
        private readonly float[] buffer;
        private int writePos;
        private int readPos;
        private int availableData;
        private readonly object syncLock = new object();
        
        public RingBuffer(int size)
        {
            buffer = new float[size];
        }
        
        public int Available => availableData;
        
        public void Write(float[] data)
        {
            lock (syncLock)
            {
                int dataLength = data.Length;
                int bufferLength = buffer.Length;
                
                for (int i = 0; i < dataLength; i++)
                {
                    buffer[writePos] = data[i];
                    writePos = (writePos + 1) % bufferLength;
                    
                    if (availableData < bufferLength)
                    {
                        availableData++;
                    }
                    else
                    {
                        readPos = (readPos + 1) % bufferLength;
                    }
                }
            }
        }
        
        public int Read(float[] data, int count)
        {
            lock (syncLock)
            {
                int toRead = Math.Min(count, Math.Min(availableData, data.Length));
                
                for (int i = 0; i < toRead; i++)
                {
                    data[i] = buffer[readPos];
                    readPos = (readPos + 1) % buffer.Length;
                }
                
                availableData -= toRead;
                return toRead;
            }
        }
        
        public void Clear()
        {
            lock (syncLock)
            {
                writePos = 0;
                readPos = 0;
                availableData = 0;
                Array.Clear(buffer, 0, buffer.Length);
            }
        }
        
        public void Dispose()
        {
            Clear();
        }
    }

    // éŸ³é¢‘é€šé“
    public class AudioChannel
    {
        public float[] Data { get; private set; }
        public int Channels { get; private set; }
        public int SampleCount { get; private set; }
        
        public AudioChannel(int maxSamples)
        {
            Data = new float[maxSamples];
        }
        
        public void LoadData(float[] sourceData, int channels)
        {
            int copyLength = Math.Min(sourceData.Length, Data.Length);
            Array.Copy(sourceData, Data, copyLength);
            Channels = channels;
            SampleCount = copyLength / channels;
        }
    }

    // å¤„ç†é€‰é¡¹
    public class ProcessingOptions
    {
        public float Gain { get; set; } = 1.0f;
        public bool EnableNoiseReduction { get; set; } = true;
        public bool EnableSpectralGating { get; set; } = true;
        public bool EnableVoiceEnhancement { get; set; } = true;
        public float MaxLevel { get; set; } = 0.95f;
        public float VoiceBoost { get; set; } = 1.0f;
    }

    // æ··éŸ³é€‰é¡¹
    public class MixingOptions
    {
        public bool EnableSmartMixing { get; set; } = true;
        public float IntelligentBalanceRatio { get; set; } = 2.5f;
        public bool EnableCompression { get; set; } = true;
        public float CompressionThreshold { get; set; } = 0.7f;
        public float CompressionRatio { get; set; } = 2.0f;
    }

    // éŸ³é¢‘å¤„ç†ç®¡é“
    public class AudioProcessingPipeline
    {
        public void AddSystemAudioProcessing(AudioChannel channel, ProcessingOptions options)
        {
            // ç³»ç»ŸéŸ³é¢‘å¤„ç†å®ç°
            if (options.EnableNoiseReduction)
            {
                NoiseReductionProcessor.ProcessSystemAudio(channel.Data, channel.SampleCount * channel.Channels);
            }
            
            if (options.EnableSpectralGating)
            {
                SpectralGate.ProcessChannel(channel.Data, channel.SampleCount * channel.Channels);
            }
            
            ApplyGain(channel.Data, options.Gain, channel.SampleCount * channel.Channels);
            ApplyLimiting(channel.Data, options.MaxLevel, channel.SampleCount * channel.Channels);
        }
        
        public void AddMicrophoneProcessing(AudioChannel channel, ProcessingOptions options)
        {
            // éº¦å…‹é£éŸ³é¢‘å¤„ç†å®ç°
            if (options.EnableVoiceEnhancement)
            {
                VoiceEnhancer.ProcessChannel(channel.Data, channel.SampleCount);
            }
            
            if (options.EnableNoiseReduction)
            {
                NoiseReductionProcessor.ProcessMicrophoneAudio(channel.Data, channel.SampleCount);
            }
            
            ApplyGain(channel.Data, options.Gain * options.VoiceBoost, channel.SampleCount);
        }
        
        private void ApplyGain(float[] data, float gain, int length)
        {
            for (int i = 0; i < length; i++)
            {
                data[i] *= gain;
            }
        }
        
        private void ApplyLimiting(float[] data, float limit, int length)
        {
            for (int i = 0; i < length; i++)
            {
                data[i] = Math.Max(-limit, Math.Min(limit, data[i]));
            }
        }
    }

    // æ··éŸ³æ€»çº¿
    public class AudioMixingBus : IDisposable
    {
        private float[] mixBuffer;
        
        public AudioMixingBus()
        {
            mixBuffer = new float[8192]; // æœ€å¤§æ··éŸ³ç¼“å†²åŒº
        }
        
        public float[] MixChannels(AudioChannel systemChannel, AudioChannel micChannel, MixingOptions options)
        {
            int outputSamples = Math.Max(systemChannel.SampleCount, micChannel.SampleCount);
            if (outputSamples == 0) return Array.Empty<float>();
            
            // ç¡®ä¿è¾“å‡ºç¼“å†²åŒºè¶³å¤Ÿå¤§
            int outputLength = outputSamples * 2; // ç«‹ä½“å£°
            if (mixBuffer.Length < outputLength)
            {
                mixBuffer = new float[outputLength];
            }
            else
            {
                Array.Clear(mixBuffer, 0, outputLength);
            }
            
            // æ™ºèƒ½æ··éŸ³ç®—æ³•
            for (int i = 0; i < outputSamples; i++)
            {
                float systemLeft = 0f, systemRight = 0f;
                float micValue = 0f;
                
                // è·å–ç³»ç»ŸéŸ³é¢‘
                if (i < systemChannel.SampleCount)
                {
                    if (systemChannel.Channels == 1)
                    {
                        systemLeft = systemRight = systemChannel.Data[i];
                    }
                    else
                    {
                        int idx = i * 2;
                        systemLeft = systemChannel.Data[idx];
                        systemRight = systemChannel.Data[idx + 1];
                    }
                }
                
                // è·å–éº¦å…‹é£éŸ³é¢‘
                if (i < micChannel.SampleCount)
                {
                    micValue = micChannel.Data[i];
                }
                
                // æ™ºèƒ½æ··éŸ³ - å¢å¼ºç‰ˆç®—æ³•
                if (options.EnableSmartMixing)
                {
                    float micLevel = Math.Abs(micValue);
                    float systemLevel = Math.Max(Math.Abs(systemLeft), Math.Abs(systemRight));
                    
                    // è®¡ç®—çŸ­æœŸèƒ½é‡ï¼ˆä½¿ç”¨æ»‘åŠ¨çª—å£ï¼‰
                    float micEnergy = micLevel * micLevel;
                    float systemEnergy = systemLevel * systemLevel;
                    
                    // åŠ¨æ€è¯­éŸ³æ£€æµ‹å’Œå¹³è¡¡
                    if (micLevel > 0.08f) // æé«˜è¯­éŸ³æ£€æµ‹é˜ˆå€¼
                    {
                        // æ ¹æ®è¯­éŸ³å¼ºåº¦åŠ¨æ€è°ƒæ•´ç³»ç»ŸéŸ³é¢‘
                        float voiceStrength = Math.Min(1.0f, micLevel * 8.0f);
                        float dynamicReduction = 0.85f * voiceStrength; // æ›´å¼ºçš„åŠ¨æ€æŠ‘åˆ¶
                        
                        // ä½¿ç”¨å¹³æ»‘çš„è¡°å‡æ›²çº¿
                        float smoothFactor = (float)Math.Pow(1.0f - dynamicReduction, 1.5);
                        systemLeft *= smoothFactor;
                        systemRight *= smoothFactor;
                        
                        // å¢å¼ºè¯­éŸ³æ¸…æ™°åº¦
                        float voiceBoost = 1.0f + voiceStrength * 0.4f;
                        micValue *= voiceBoost;
                    }
                    else if (micLevel > 0.02f) // è½»å¾®è¯­éŸ³æ´»åŠ¨
                    {
                        // æ¸©å’Œçš„ç³»ç»ŸéŸ³é¢‘è¡°å‡
                        float reduction = micLevel * 5.0f;
                        systemLeft *= (1.0f - reduction * 0.3f);
                        systemRight *= (1.0f - reduction * 0.3f);
                    }
                    
                    // é«˜çº§ç³»ç»ŸéŸ³é¢‘é™åˆ¶
                    if (systemLevel > 0.2f) // æ›´ä½çš„é™åˆ¶é˜ˆå€¼
                    {
                        // ä½¿ç”¨è½¯é™åˆ¶æ›²çº¿
                        float excess = systemLevel - 0.2f;
                        float compressionRatio = 1.0f / (1.0f + excess * 10.0f);
                        systemLeft *= compressionRatio;
                        systemRight *= compressionRatio;
                    }
                    
                    // é˜²æ­¢æ··éŸ³åçš„å‰Šæ³¢
                    float totalLevel = Math.Abs(systemLeft + micValue) + Math.Abs(systemRight + micValue);
                    if (totalLevel > 1.8f)
                    {
                        float scaleFactor = 1.8f / totalLevel;
                        systemLeft *= scaleFactor;
                        systemRight *= scaleFactor;
                        micValue *= scaleFactor;
                    }
                }
                
                // æ··åˆåˆ°è¾“å‡º
                mixBuffer[i * 2] = systemLeft + micValue;
                mixBuffer[i * 2 + 1] = systemRight + micValue;
            }
            
            // åº”ç”¨åŠ¨æ€å‹ç¼©
            if (options.EnableCompression)
            {
                DynamicsProcessor.ApplyCompression(mixBuffer, outputLength, 
                    options.CompressionThreshold, options.CompressionRatio);
            }
            
            // åˆ›å»ºè¾“å‡ºæ•°ç»„
            float[] result = new float[outputLength];
            Array.Copy(mixBuffer, result, outputLength);
            return result;
        }
        
        public void Reset()
        {
            if (mixBuffer != null)
            {
                Array.Clear(mixBuffer, 0, mixBuffer.Length);
            }
        }
        
        public void Dispose()
        {
            mixBuffer = null;
        }
    }

    // è¾…åŠ©å¤„ç†å™¨ç±»
    public static class NoiseReductionProcessor
    {
        private static readonly float[] noiseSpectrum = new float[512];
        private static int noiseProfileFrames = 0;
        
        public static void ProcessSystemAudio(float[] data, int length)
        {
            // æ›´é«˜çº§çš„ç³»ç»ŸéŸ³é¢‘é™å™ª - é’ˆå¯¹ç”µç£å¹²æ‰°å’Œåº•å™ª
            const float baseThreshold = 0.0025f;  // æ›´ä½çš„é˜ˆå€¼ï¼Œä¿ç•™æ›´å¤šç»†èŠ‚
            const float maxReduction = 0.85f;     // æ›´å¼ºçš„é™å™ª
            const float smoothing = 0.15f;        // å¹³æ»‘è¿‡æ¸¡
            
            // è‡ªé€‚åº”å™ªå£°é—¨
            float rms = CalculateRMS(data, length);
            float adaptiveThreshold = Math.Max(baseThreshold, rms * 0.05f);
            
            // å¤šé˜¶æ®µé™å™ª
            for (int i = 0; i < length; i++)
            {
                float sample = data[i];
                float absSample = Math.Abs(sample);
                
                // ç¬¬ä¸€é˜¶æ®µï¼šç¡¬å™ªå£°é—¨
                if (absSample < adaptiveThreshold * 0.5f)
                {
                    data[i] = 0; // å®Œå…¨æ¶ˆé™¤æä½ç”µå¹³å™ªå£°
                }
                // ç¬¬äºŒé˜¶æ®µï¼šè½¯è¿‡æ¸¡åŒº
                else if (absSample < adaptiveThreshold * 2f)
                {
                    // ä½¿ç”¨æ›´å¹³æ»‘çš„è¿‡æ¸¡æ›²çº¿
                    float normalizedLevel = (absSample - adaptiveThreshold * 0.5f) / (adaptiveThreshold * 1.5f);
                    float reduction = maxReduction * (float)Math.Pow(1 - normalizedLevel, 2);
                    data[i] = sample * (1 - reduction);
                }
                // ç¬¬ä¸‰é˜¶æ®µï¼šè½»å¾®é™å™ª
                else if (absSample < adaptiveThreshold * 4f)
                {
                    float reduction = maxReduction * 0.2f * (1 - (absSample - adaptiveThreshold * 2f) / (adaptiveThreshold * 2f));
                    data[i] = sample * (1 - reduction);
                }
                
                // åº”ç”¨å¹³æ»‘æ»¤æ³¢å‡å°‘çªå˜
                if (i > 0)
                {
                    data[i] = data[i] * (1 - smoothing) + data[i - 1] * smoothing;
                }
            }
        }
        
        public static void ProcessMicrophoneAudio(float[] data, int length)
        {
            // æ™ºèƒ½è¯­éŸ³é™å™ª - ä¿ç•™è¯­éŸ³ï¼Œå»é™¤èƒŒæ™¯å™ªéŸ³
            const float voiceThreshold = 0.001f;  // æ›´ä½çš„é˜ˆå€¼ä»¥ä¿ç•™å¾®å¼±è¯­éŸ³
            const float maxReduction = 0.4f;      // æ¸©å’Œçš„é™å™ªä»¥ä¿æŠ¤è¯­éŸ³
            
            // æ£€æµ‹è¯­éŸ³æ´»åŠ¨
            bool voiceDetected = DetectVoiceActivity(data, length);
            float adaptiveReduction = voiceDetected ? maxReduction * 0.5f : maxReduction;
            
            for (int i = 0; i < length; i++)
            {
                float sample = data[i];
                float absSample = Math.Abs(sample);
                
                if (absSample < voiceThreshold)
                {
                    // å¯¹æä½ç”µå¹³åº”ç”¨é™å™ª
                    data[i] = sample * (1 - adaptiveReduction);
                }
                else if (absSample < voiceThreshold * 3f && !voiceDetected)
                {
                    // æ— è¯­éŸ³æ—¶åŠ å¼ºé™å™ª
                    float factor = (absSample - voiceThreshold) / (voiceThreshold * 2f);
                    data[i] = sample * (1 - adaptiveReduction * (1 - factor * factor));
                }
            }
        }
        
        private static float CalculateRMS(float[] data, int length)
        {
            float sum = 0;
            for (int i = 0; i < length; i++)
            {
                sum += data[i] * data[i];
            }
            return (float)Math.Sqrt(sum / length);
        }
        
        private static bool DetectVoiceActivity(float[] data, int length)
        {
            // ç®€å•çš„è¯­éŸ³æ´»åŠ¨æ£€æµ‹
            float energy = CalculateRMS(data, length);
            int zeroCrossings = 0;
            
            for (int i = 1; i < length; i++)
            {
                if (Math.Sign(data[i]) != Math.Sign(data[i - 1]))
                {
                    zeroCrossings++;
                }
            }
            
            float zeroCrossingRate = (float)zeroCrossings / length;
            
            // è¯­éŸ³ç‰¹å¾ï¼šä¸­ç­‰èƒ½é‡ï¼Œé€‚ä¸­çš„è¿‡é›¶ç‡
            return energy > 0.01f && zeroCrossingRate > 0.05f && zeroCrossingRate < 0.5f;
        }
    }

    public class SpectralGate
    {
        private readonly int sampleRate;
        
        public SpectralGate(int sampleRate)
        {
            this.sampleRate = sampleRate;
        }
        
        public float[] Process(float[] input)
        {
            // é¢‘è°±é—¨æ§å®ç°
            return input; // ç®€åŒ–ç‰ˆæœ¬
        }
        
        public static void ProcessChannel(float[] data, int length)
        {
            // é™æ€å¤„ç†æ–¹æ³•
            const float gateThreshold = 0.003f;
            
            for (int i = 0; i < length; i++)
            {
                if (Math.Abs(data[i]) < gateThreshold)
                {
                    data[i] = 0f;
                }
            }
        }
        
        public void Reset()
        {
            // é‡ç½®çŠ¶æ€
        }
    }

    public class AdaptiveFilter
    {
        public float[] RemoveElectromagneticInterference(float[] input, int channels)
        {
            // ç”µç£å¹²æ‰°æ¶ˆé™¤
            return input; // ç®€åŒ–ç‰ˆæœ¬
        }
        
        public void Reset()
        {
            // é‡ç½®çŠ¶æ€
        }
    }

    public static class DynamicsProcessor
    {
        public static void ApplyCompression(float[] data, int length, float threshold, float ratio)
        {
            for (int i = 0; i < length; i++)
            {
                float sample = data[i];
                float absSample = Math.Abs(sample);
                
                if (absSample > threshold)
                {
                    float excess = absSample - threshold;
                    float compressedExcess = excess / ratio;
                    float newLevel = threshold + compressedExcess;
                    data[i] = sample * (newLevel / absSample);
                }
            }
        }
        
        public static float[] ApplyLimiting(float[] input, float limit)
        {
            float[] output = new float[input.Length];
            
            for (int i = 0; i < input.Length; i++)
            {
                float sample = input[i];
                float absSample = Math.Abs(sample);
                
                if (absSample > limit)
                {
                    output[i] = sample * (limit / absSample);
                }
                else
                {
                    output[i] = sample;
                }
            }
            
            return output;
        }
    }

    public class VoiceEnhancer
    {
        public float[] Process(float[] input)
        {
            // è¯­éŸ³å¢å¼ºå®ç°
            return input; // ç®€åŒ–ç‰ˆæœ¬
        }
        
        public static void ProcessChannel(float[] data, int length)
        {
            // é™æ€å¤„ç†æ–¹æ³•
            const float voiceBoost = 1.2f;
            
            for (int i = 0; i < length; i++)
            {
                float sample = data[i];
                float absSample = Math.Abs(sample);
                
                // è¯­éŸ³é¢‘æ®µå¢å¼º
                if (absSample > 0.05f && absSample < 0.6f)
                {
                    data[i] = sample * voiceBoost;
                }
            }
        }
        
        public void Reset()
        {
            // é‡ç½®çŠ¶æ€
        }
    }

    public static class HighQualityResampler
    {
        public static float[] Resample(float[] input, int fromRate, int toRate, int channels)
        {
            if (fromRate == toRate) return input;
            
            double ratio = (double)toRate / fromRate;
            int outputLength = (int)(input.Length * ratio);
            float[] output = new float[outputLength];
            
            // Lanczosé‡é‡‡æ ·ç®—æ³•
            for (int i = 0; i < outputLength; i++)
            {
                double sourceIndex = i / ratio;
                output[i] = LanczosInterpolate(input, sourceIndex, 3);
            }
            
            return output;
        }
        
        private static float LanczosInterpolate(float[] input, double index, int a)
        {
            int baseIndex = (int)Math.Floor(index);
            double fraction = index - baseIndex;
            
            float sum = 0f;
            float weightSum = 0f;
            
            for (int i = -a + 1; i <= a; i++)
            {
                int sampleIndex = baseIndex + i;
                if (sampleIndex >= 0 && sampleIndex < input.Length)
                {
                    double x = i - fraction;
                    double weight = LanczosKernel(x, a);
                    sum += (float)(input[sampleIndex] * weight);
                    weightSum += (float)weight;
                }
            }
            
            return weightSum > 0 ? sum / weightSum : 0f;
        }
        
        private static double LanczosKernel(double x, int a)
        {
            if (x == 0) return 1.0;
            if (Math.Abs(x) >= a) return 0.0;
            
            double pix = Math.PI * x;
            double pixa = pix / a;
            return Math.Sin(pix) / pix * Math.Sin(pixa) / pixa;
        }
    }
} 