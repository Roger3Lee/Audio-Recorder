using NAudio.Wave;
using NAudio.CoreAudioApi;
using SoundTouch;
using MathNet.Numerics;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace AudioRecorder
{
    public enum RecordingMode
    {
        Mixed,      // 混合模式
        Separate    // 分离模式
    }

    public enum AudioQuality
    {
        Standard,   // 44.1kHz, 16-bit
        High,       // 48kHz, 24-bit
        Studio      // 96kHz, 32-bit
    }

    public class AudioRecorderEngine : IDisposable
    {
        // 音频输入设备
        private WasapiLoopbackCapture? loopbackCapture;
        private WaveInEvent? waveIn;
        
        // 音频输出文件
        private WaveFileWriter? mixedAudioWriter;
        private WaveFileWriter? systemAudioWriter;
        private WaveFileWriter? micAudioWriter;
        
        // 录制状态
        private bool isRecording = false;
        private string outputDirectory;
        private NAudio.Wave.WaveFormat outputFormat;
        private readonly object lockObject = new object();

        // 专业音频处理组件
        private MasterAudioProcessor masterProcessor;
        private AudioMixingBus mixingBus;
        
        // 高性能音频缓冲区
        private AdvancedCircularBuffer systemBuffer;
        private AdvancedCircularBuffer micBuffer;
        
        // 录制配置
        private bool recordSystemAudio = true;
        private bool recordMicrophone = true;
        private RecordingMode recordingMode = RecordingMode.Mixed;
        
        // 优化的音频参数 - 基于专业录音标准
        private float microphoneGain = 4.5f;      // 提高麦克风增益，确保清晰语音
        private float systemAudioGain = 0.12f;    // 大幅降低系统音频，最小化噪音
        
        // 音质设置
        private AudioQuality audioQuality = AudioQuality.High;
        
        // 专业音频处理参数
        private bool enableNoiseReduction = true;
        private bool enableDynamicRangeCompression = true;
        private bool enableVoiceEnhancement = true;
        private bool enableSystemAudioNoiseReduction = true;
        private bool enableSmartMixing = true;
        private bool enableSpectralGating = true;         // 频谱门控
        private bool enableAdaptiveFiltering = true;      // 自适应滤波
        
        // 处理参数
        private float compressionThreshold = 0.65f;      // 更低的压缩阈值
        private float compressionRatio = 3.0f;           // 更高的压缩比
        private float voiceFreqBoost = 1.8f;             // 更强的语音增强
        private float systemAudioMaxLevel = 0.2f;        // 更严格的系统音频限制
        private float intelligentBalanceRatio = 5.0f;    // 更智能的动态平衡
        private int bufferLatency = 10;                  // 超低延迟
        
        // 动态状态跟踪
        private float systemNoiseProfile = 0.01f;         // 系统噪声配置文件
        private float currentSystemLevel = 0f;            // 当前系统音量
        private float currentMicLevel = 0f;               // 当前麦克风音量
        private float[] systemEnvelopeBuffer = new float[100];  // 系统音频包络缓冲
        private float[] micEnvelopeBuffer = new float[100];     // 麦克风包络缓冲
        private int envelopeIndex = 0;                    // 包络缓冲索引

        public event EventHandler<string>? StatusChanged;
        public event EventHandler<Exception>? ErrorOccurred;

        public AudioRecorderEngine()
        {
            outputDirectory = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "AudioRecordings");
            Directory.CreateDirectory(outputDirectory);
            
            SetAudioQuality(audioQuality);
            InitializeProfessionalAudioSystem();
        }

        // 公共属性
        public bool IsRecording => isRecording;
        public RecordingMode Mode { get; set; } = RecordingMode.Mixed;
        
        public AudioQuality Quality 
        { 
            get => audioQuality; 
            set 
            { 
                audioQuality = value;
                SetAudioQuality(value);
            }
        }
        
        public float MicrophoneGain 
        { 
            get => microphoneGain; 
            set => microphoneGain = Math.Max(0.1f, Math.Min(8.0f, value));
        }
        
        public float SystemAudioGain 
        { 
            get => systemAudioGain; 
            set => systemAudioGain = Math.Max(0.05f, Math.Min(1.0f, value));
        }
        
        public bool EnableNoiseReduction 
        { 
            get => enableNoiseReduction; 
            set => enableNoiseReduction = value; 
        }
        
        public bool EnableDynamicRangeCompression 
        { 
            get => enableDynamicRangeCompression; 
            set => enableDynamicRangeCompression = value; 
        }
        
        public bool EnableVoiceEnhancement 
        { 
            get => enableVoiceEnhancement; 
            set => enableVoiceEnhancement = value; 
        }
        
        public bool EnableSystemAudioNoiseReduction 
        { 
            get => enableSystemAudioNoiseReduction; 
            set => enableSystemAudioNoiseReduction = value; 
        }
        
        public bool EnableSmartMixing 
        { 
            get => enableSmartMixing; 
            set => enableSmartMixing = value; 
        }
        
        public float SystemAudioMaxLevel 
        { 
            get => systemAudioMaxLevel; 
            set => systemAudioMaxLevel = Math.Max(0.1f, Math.Min(0.8f, value)); 
        }

        private void SetAudioQuality(AudioQuality quality)
        {
            outputFormat = quality switch
            {
                AudioQuality.Standard => new NAudio.Wave.WaveFormat(44100, 16, 2),
                AudioQuality.High => new NAudio.Wave.WaveFormat(48000, 24, 2),
                AudioQuality.Studio => new NAudio.Wave.WaveFormat(96000, 32, 2),
                _ => new NAudio.Wave.WaveFormat(48000, 24, 2)
            };
        }

        private void InitializeProfessionalAudioSystem()
        {
            try
            {
                // 初始化高精度循环缓冲区
                int bufferSize = outputFormat.SampleRate * 10; // 10秒缓冲
                systemBuffer = new AdvancedCircularBuffer(bufferSize);
                micBuffer = new AdvancedCircularBuffer(bufferSize);
                
                // 初始化专业音频处理器
                masterProcessor = new MasterAudioProcessor(outputFormat.SampleRate);
                
                // 初始化混音总线
                mixingBus = new AudioMixingBus();
                
                StatusChanged?.Invoke(this, "🎛️ 专业音频系统已初始化 (Studio-Grade Processing)");
            }
            catch (Exception ex)
            {
                ErrorOccurred?.Invoke(this, new Exception("专业音频系统初始化失败", ex));
            }
        }

        public void StartRecording(bool recordSystemAudio = true, bool recordMicrophone = true, RecordingMode mode = RecordingMode.Mixed)
        {
            if (isRecording)
            {
                StatusChanged?.Invoke(this, "录制已在进行中");
                return;
            }

            this.recordSystemAudio = recordSystemAudio;
            this.recordMicrophone = recordMicrophone;
            this.recordingMode = mode;

            if (!recordSystemAudio && !recordMicrophone)
            {
                StatusChanged?.Invoke(this, "请至少选择一种录制源");
                return;
            }

            try
            {
                string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                string qualityLabel = audioQuality.ToString();

                if (recordingMode == RecordingMode.Mixed)
                {
                    string mixedAudioPath = Path.Combine(outputDirectory, $"MixedAudio_Studio_{qualityLabel}_{timestamp}.wav");
                    mixedAudioWriter = new WaveFileWriter(mixedAudioPath, outputFormat);
                    StatusChanged?.Invoke(this, $"🎚️ 录音室级混合录制已开始 ({GetQualityDescription()})");
                    StatusChanged?.Invoke(this, $"💾 保存到: {mixedAudioPath}");
                    
                    if (recordMicrophone)
                    {
                        StatusChanged?.Invoke(this, $"🎤 麦克风已启用 - 增益: {microphoneGain:F1}x (录音室优化)");
                        StatusChanged?.Invoke(this, "🔇 多级智能降噪已启用");
                        StatusChanged?.Invoke(this, "🗣️ AI语音增强已启用");
                    }
                    
                    if (recordSystemAudio)
                    {
                        StatusChanged?.Invoke(this, $"🔊 系统音频已启用 - 增益: {systemAudioGain:F2}x (深度降噪)");
                        StatusChanged?.Invoke(this, "⚡ 电磁干扰消除已启用");
                        StatusChanged?.Invoke(this, "🎯 频谱门控已启用");
                    }
                    
                    StatusChanged?.Invoke(this, "🧠 智能自适应混音已启用");
                    StatusChanged?.Invoke(this, "📊 实时频谱分析已启用");
                }
                else
                {
                    if (recordSystemAudio)
                    {
                        string systemAudioPath = Path.Combine(outputDirectory, $"SystemAudio_Studio_{qualityLabel}_{timestamp}.wav");
                        systemAudioWriter = new WaveFileWriter(systemAudioPath, outputFormat);
                        StatusChanged?.Invoke(this, $"系统音频将保存到: {systemAudioPath}");
                    }

                    if (recordMicrophone)
                    {
                        string micAudioPath = Path.Combine(outputDirectory, $"Microphone_Studio_{qualityLabel}_{timestamp}.wav");
                        NAudio.Wave.WaveFormat micFormat = new NAudio.Wave.WaveFormat(outputFormat.SampleRate, outputFormat.BitsPerSample, 1);
                        micAudioWriter = new WaveFileWriter(micAudioPath, micFormat);
                        StatusChanged?.Invoke(this, $"麦克风音频将保存到: {micAudioPath}");
                    }
                }

                // 重置缓冲区和状态
                systemBuffer.Clear();
                micBuffer.Clear();
                ResetDynamicStates();

                if (recordSystemAudio)
                {
                    StartSystemAudioCapture(timestamp);
                }

                if (recordMicrophone)
                {
                    StartMicrophoneCapture(timestamp);
                }

                isRecording = true;
                string modeText = recordingMode == RecordingMode.Mixed ? "混合" : "分离";
                StatusChanged?.Invoke(this, $"✅ {modeText}模式录制已开始 (录音室品质)");
            }
            catch (Exception ex)
            {
                ErrorOccurred?.Invoke(this, ex);
                StopRecording();
            }
        }

        private void ResetDynamicStates()
        {
            systemNoiseProfile = 0.01f;
            currentSystemLevel = 0f;
            currentMicLevel = 0f;
            Array.Clear(systemEnvelopeBuffer, 0, systemEnvelopeBuffer.Length);
            Array.Clear(micEnvelopeBuffer, 0, micEnvelopeBuffer.Length);
            envelopeIndex = 0;
            masterProcessor?.Reset();
            mixingBus?.Reset();
        }

        private string GetQualityDescription()
        {
            return audioQuality switch
            {
                AudioQuality.Standard => "44.1kHz/16bit/立体声",
                AudioQuality.High => "48kHz/24bit/立体声",
                AudioQuality.Studio => "96kHz/32bit/立体声",
                _ => "48kHz/24bit/立体声"
            };
        }

        private void StartSystemAudioCapture(string timestamp)
        {
            loopbackCapture = new WasapiLoopbackCapture();
            
            // 设置更小的缓冲区以减少延迟
            loopbackCapture.ShareMode = AudioClientShareMode.Shared;

            if (recordingMode == RecordingMode.Separate)
            {
                string qualityLabel = audioQuality.ToString();
                string systemAudioPath = Path.Combine(outputDirectory, $"SystemAudio_Studio_{qualityLabel}_{timestamp}.wav");
                systemAudioWriter = new WaveFileWriter(systemAudioPath, loopbackCapture.WaveFormat);
            }
            
            loopbackCapture.DataAvailable += (sender, e) =>
            {
                if (!isRecording) return;

                try
                {
                    ProcessSystemAudioData(e.Buffer, e.BytesRecorded, loopbackCapture.WaveFormat);
                }
                catch (Exception ex)
                {
                    ErrorOccurred?.Invoke(this, ex);
                }
            };

            loopbackCapture.RecordingStopped += (sender, e) =>
            {
                if (recordingMode == RecordingMode.Separate)
                {
                    systemAudioWriter?.Dispose();
                    systemAudioWriter = null;
                }
            };

            loopbackCapture.StartRecording();
        }

        private void StartMicrophoneCapture(string timestamp)
        {
            waveIn = new WaveInEvent();
            waveIn.WaveFormat = new NAudio.Wave.WaveFormat(outputFormat.SampleRate, outputFormat.BitsPerSample, 1);
            waveIn.BufferMilliseconds = bufferLatency;
            waveIn.NumberOfBuffers = 8;  // 更多缓冲区以提高稳定性

            waveIn.DataAvailable += (sender, e) =>
            {
                if (!isRecording) return;

                try
                {
                    ProcessMicrophoneData(e.Buffer, e.BytesRecorded, waveIn.WaveFormat);
                }
                catch (Exception ex)
                {
                    ErrorOccurred?.Invoke(this, ex);
                }
            };

            waveIn.RecordingStopped += (sender, e) =>
            {
                if (recordingMode == RecordingMode.Separate)
                {
                    micAudioWriter?.Dispose();
                    micAudioWriter = null;
                }
            };

            waveIn.StartRecording();
        }

        private void ProcessSystemAudioData(byte[] buffer, int bytesRecorded, NAudio.Wave.WaveFormat format)
        {
            if (recordingMode == RecordingMode.Mixed)
            {
                // 转换为浮点数据
                float[] floatData = ConvertToFloat32(buffer, bytesRecorded, format);
                
                // 专业音频预处理
                floatData = masterProcessor.ProcessSystemAudioPreMix(floatData, systemAudioGain);
                
                // 重采样（如果需要）
                if (format.SampleRate != outputFormat.SampleRate)
                {
                    floatData = ResampleAudio(floatData, format.SampleRate, outputFormat.SampleRate, format.Channels);
                }
                
                // 存储到缓冲区
                lock (lockObject)
                {
                    systemBuffer.Write(floatData);
                    ProcessMixedAudioOutput();
                }
            }
            else
            {
                // 分离模式处理
                ProcessSeparateSystemAudio(buffer, bytesRecorded, format);
            }
        }

        private void ProcessMicrophoneData(byte[] buffer, int bytesRecorded, NAudio.Wave.WaveFormat format)
        {
            if (recordingMode == RecordingMode.Mixed)
            {
                // 转换为浮点数据
                float[] floatData = ConvertToFloat32(buffer, bytesRecorded, format);
                
                // 专业音频预处理
                floatData = masterProcessor.ProcessMicrophoneAudioPreMix(floatData, microphoneGain);
                
                // 存储到缓冲区
                lock (lockObject)
                {
                    micBuffer.Write(floatData);
                    ProcessMixedAudioOutput();
                }
            }
            else
            {
                // 分离模式处理
                ProcessSeparateMicrophoneAudio(buffer, bytesRecorded, format);
            }
        }

        private void ProcessSeparateSystemAudio(byte[] buffer, int bytesRecorded, NAudio.Wave.WaveFormat format)
        {
            if (Math.Abs(systemAudioGain - 1.0f) > 0.01f || enableSystemAudioNoiseReduction)
            {
                float[] floats = ConvertToFloat32(buffer, bytesRecorded, format);
                floats = masterProcessor.ProcessSystemAudioSeparate(floats, systemAudioGain);
                byte[] processedBytes = ConvertFromFloat32(floats, format);
                systemAudioWriter?.Write(processedBytes, 0, processedBytes.Length);
            }
            else
            {
                systemAudioWriter?.Write(buffer, 0, bytesRecorded);
            }
        }

        private void ProcessSeparateMicrophoneAudio(byte[] buffer, int bytesRecorded, NAudio.Wave.WaveFormat format)
        {
            float[] floats = ConvertToFloat32(buffer, bytesRecorded, format);
            floats = masterProcessor.ProcessMicrophoneAudioSeparate(floats, microphoneGain);
            byte[] processedBytes = ConvertFromFloat32(floats, format);
            micAudioWriter?.Write(processedBytes, 0, processedBytes.Length);
        }

        private void ProcessMixedAudioOutput()
        {
            if (mixedAudioWriter == null || recordingMode != RecordingMode.Mixed) return;

            // 使用专业音频块大小
            const int blockSize = 256; // 低延迟专业标准
            
            bool hasSystemAudio = recordSystemAudio && systemBuffer.Available >= blockSize * 2;
            bool hasMicAudio = recordMicrophone && micBuffer.Available >= blockSize;

            if (!hasSystemAudio && !hasMicAudio) return;
            
            // 读取数据并进行智能混音
            float[] systemData = new float[blockSize * 2];
            float[] micData = new float[blockSize];
            
            if (hasSystemAudio)
            {
                systemBuffer.Read(systemData, blockSize * 2);
            }
            
            if (hasMicAudio)
            {
                micBuffer.Read(micData, blockSize);
            }
            
            // 使用新的混音处理器
            float[] mixedOutput = masterProcessor.MixAudioChannels(
                systemData, 
                micData, 
                hasSystemAudio, 
                hasMicAudio,
                enableSmartMixing,
                enableDynamicRangeCompression);
            
            // 写入文件
            if (mixedOutput.Length > 0)
            {
                byte[] outputBytes = ConvertFromFloat32(mixedOutput, outputFormat);
                mixedAudioWriter.Write(outputBytes, 0, outputBytes.Length);
            }
        }

        private float[] ConvertToFloat32(byte[] input, int length, NAudio.Wave.WaveFormat format)
        {
            int samplesCount = length / (format.BitsPerSample / 8);
            float[] output = new float[samplesCount];

            switch (format.BitsPerSample)
            {
                case 16:
                    for (int i = 0; i < samplesCount; i++)
                    {
                        short sample = BitConverter.ToInt16(input, i * 2);
                        output[i] = sample / 32768f;
                    }
                    break;
                    
                case 24:
                    for (int i = 0; i < samplesCount; i++)
                    {
                        int sample = (input[i * 3] << 8) | (input[i * 3 + 1] << 16) | (input[i * 3 + 2] << 24);
                        output[i] = sample / (float)(1 << 31);
                    }
                    break;
                    
                case 32:
                    for (int i = 0; i < samplesCount; i++)
                    {
                        int sample = BitConverter.ToInt32(input, i * 4);
                        output[i] = sample / (float)(1L << 31);
                    }
                    break;
            }

            return output;
        }

        private float[] ResampleAudio(float[] input, int fromRate, int toRate, int channels)
        {
            if (fromRate == toRate) return input;
            
            // 使用SoundTouch进行高质量重采样
            using (var soundTouch = new SoundTouchProcessor())
            {
                soundTouch.SetSampleRate(fromRate);
                soundTouch.SetChannels(channels);
                soundTouch.SetRate((float)toRate / fromRate);
                
                soundTouch.PutSamples(input);
                soundTouch.Flush();
                
                var resampled = new List<float>();
                float[] buffer = new float[2048];
                
                uint received;
                do
                {
                    received = soundTouch.ReceiveSamples(buffer, (uint)buffer.Length / (uint)channels);
                    if (received > 0)
                    {
                        resampled.AddRange(buffer.Take((int)(received * channels)));
                    }
                } while (received > 0);
                
                return resampled.ToArray();
            }
        }

        private byte[] ConvertFromFloat32(float[] input, NAudio.Wave.WaveFormat format)
        {
            byte[] output = new byte[input.Length * (format.BitsPerSample / 8)];

            switch (format.BitsPerSample)
            {
                case 16:
                    for (int i = 0; i < input.Length; i++)
                    {
                        short sample = (short)Math.Max(-32768, Math.Min(32767, input[i] * 32767f));
                        byte[] bytes = BitConverter.GetBytes(sample);
                        output[i * 2] = bytes[0];
                        output[i * 2 + 1] = bytes[1];
                    }
                    break;
                    
                case 24:
                    for (int i = 0; i < input.Length; i++)
                    {
                        int sample = (int)Math.Max(-8388608, Math.Min(8388607, input[i] * 8388607f));
                        output[i * 3] = (byte)(sample & 0xFF);
                        output[i * 3 + 1] = (byte)((sample >> 8) & 0xFF);
                        output[i * 3 + 2] = (byte)((sample >> 16) & 0xFF);
                    }
                    break;
                    
                case 32:
                    for (int i = 0; i < input.Length; i++)
                    {
                        int sample = (int)Math.Max(int.MinValue, Math.Min(int.MaxValue, input[i] * 2147483647f));
                        byte[] bytes = BitConverter.GetBytes(sample);
                        Array.Copy(bytes, 0, output, i * 4, 4);
                    }
                    break;
            }

            return output;
        }

        public void StopRecording()
        {
            if (!isRecording) return;

            isRecording = false;

            try
            {
                loopbackCapture?.StopRecording();
                loopbackCapture?.Dispose();
                loopbackCapture = null;

                waveIn?.StopRecording();
                waveIn?.Dispose();
                waveIn = null;

                mixedAudioWriter?.Dispose();
                mixedAudioWriter = null;

                systemAudioWriter?.Dispose();
                systemAudioWriter = null;

                micAudioWriter?.Dispose();
                micAudioWriter = null;

                StatusChanged?.Invoke(this, "🛑 录音室级录制已停止");
            }
            catch (Exception ex)
            {
                ErrorOccurred?.Invoke(this, ex);
            }
        }

        public string[] GetAvailableMicrophones()
        {
            var microphones = new List<string>();
            for (int i = 0; i < WaveIn.DeviceCount; i++)
            {
                var deviceInfo = WaveIn.GetCapabilities(i);
                microphones.Add($"{i}: {deviceInfo.ProductName}");
            }
            return microphones.ToArray();
        }

        public void SetMicrophoneDevice(int deviceIndex)
        {
            if (waveIn != null)
            {
                waveIn.DeviceNumber = deviceIndex;
            }
        }

        public void Dispose()
        {
            StopRecording();
            masterProcessor?.Dispose();
            mixingBus?.Dispose();
            systemBuffer?.Dispose();
            micBuffer?.Dispose();
        }
    }

    // 专业音频处理器
    public class ProfessionalAudioProcessor : IDisposable
    {
        private readonly int sampleRate;
        private readonly SpectralGate spectralGate;
        private readonly AdaptiveFilter adaptiveFilter;
        private readonly VoiceEnhancer voiceEnhancer;
        
        public ProfessionalAudioProcessor(int sampleRate)
        {
            this.sampleRate = sampleRate;
            spectralGate = new SpectralGate(sampleRate);
            adaptiveFilter = new AdaptiveFilter();
            voiceEnhancer = new VoiceEnhancer();
        }
        
        public float[] PreProcessSystemAudio(float[] input, NAudio.Wave.WaveFormat format)
        {
            // 多级降噪处理
            float[] processed = spectralGate.Process(input);
            processed = adaptiveFilter.RemoveElectromagneticInterference(processed, format.Channels);
            return processed;
        }
        
        public float[] PreProcessMicrophoneAudio(float[] input)
        {
            // 语音优化处理
            float[] processed = voiceEnhancer.Process(input);
            return processed;
        }
        
        public float[] ProcessSystemAudioSeparate(float[] input, float gain)
        {
            float[] processed = spectralGate.Process(input);
            ApplyGain(processed, gain);
            return processed;
        }
        
        public float[] ProcessMicrophoneAudioSeparate(float[] input, float gain)
        {
            float[] processed = voiceEnhancer.Process(input);
            ApplyGain(processed, gain);
            return processed;
        }
        
        public float[] ApplyMasterProcessing(float[] input)
        {
            // 主输出处理链
            float[] processed = DynamicsProcessor.ApplyLimiting(input, 0.95f);
            return processed;
        }
        
        public float[] Resample(float[] input, int fromRate, int toRate, int channels)
        {
            if (fromRate == toRate) return input;
            
            // 高质量重采样算法
            return HighQualityResampler.Resample(input, fromRate, toRate, channels);
        }
        
        private void ApplyGain(float[] samples, float gain)
        {
            for (int i = 0; i < samples.Length; i++)
            {
                samples[i] *= gain;
            }
        }
        
        public void Reset()
        {
            spectralGate.Reset();
            adaptiveFilter.Reset();
            voiceEnhancer.Reset();
        }
        
        public void Dispose()
        {
            // 清理资源
        }
    }

    // 高性能环形缓冲区
    public class RingBuffer : IDisposable
    {
        private readonly float[] buffer;
        private int writePos;
        private int readPos;
        private int availableData;
        private readonly object syncLock = new object();
        
        public RingBuffer(int size)
        {
            buffer = new float[size];
        }
        
        public int Available => availableData;
        
        public void Write(float[] data)
        {
            lock (syncLock)
            {
                int dataLength = data.Length;
                int bufferLength = buffer.Length;
                
                for (int i = 0; i < dataLength; i++)
                {
                    buffer[writePos] = data[i];
                    writePos = (writePos + 1) % bufferLength;
                    
                    if (availableData < bufferLength)
                    {
                        availableData++;
                    }
                    else
                    {
                        readPos = (readPos + 1) % bufferLength;
                    }
                }
            }
        }
        
        public int Read(float[] data, int count)
        {
            lock (syncLock)
            {
                int toRead = Math.Min(count, Math.Min(availableData, data.Length));
                
                for (int i = 0; i < toRead; i++)
                {
                    data[i] = buffer[readPos];
                    readPos = (readPos + 1) % buffer.Length;
                }
                
                availableData -= toRead;
                return toRead;
            }
        }
        
        public void Clear()
        {
            lock (syncLock)
            {
                writePos = 0;
                readPos = 0;
                availableData = 0;
                Array.Clear(buffer, 0, buffer.Length);
            }
        }
        
        public void Dispose()
        {
            Clear();
        }
    }

    // 音频通道
    public class AudioChannel
    {
        public float[] Data { get; private set; }
        public int Channels { get; private set; }
        public int SampleCount { get; private set; }
        
        public AudioChannel(int maxSamples)
        {
            Data = new float[maxSamples];
        }
        
        public void LoadData(float[] sourceData, int channels)
        {
            int copyLength = Math.Min(sourceData.Length, Data.Length);
            Array.Copy(sourceData, Data, copyLength);
            Channels = channels;
            SampleCount = copyLength / channels;
        }
    }

    // 处理选项
    public class ProcessingOptions
    {
        public float Gain { get; set; } = 1.0f;
        public bool EnableNoiseReduction { get; set; } = true;
        public bool EnableSpectralGating { get; set; } = true;
        public bool EnableVoiceEnhancement { get; set; } = true;
        public float MaxLevel { get; set; } = 0.95f;
        public float VoiceBoost { get; set; } = 1.0f;
    }

    // 混音选项
    public class MixingOptions
    {
        public bool EnableSmartMixing { get; set; } = true;
        public float IntelligentBalanceRatio { get; set; } = 2.5f;
        public bool EnableCompression { get; set; } = true;
        public float CompressionThreshold { get; set; } = 0.7f;
        public float CompressionRatio { get; set; } = 2.0f;
    }

    // 音频处理管道
    public class AudioProcessingPipeline
    {
        public void AddSystemAudioProcessing(AudioChannel channel, ProcessingOptions options)
        {
            // 系统音频处理实现
            if (options.EnableNoiseReduction)
            {
                NoiseReductionProcessor.ProcessSystemAudio(channel.Data, channel.SampleCount * channel.Channels);
            }
            
            if (options.EnableSpectralGating)
            {
                SpectralGate.ProcessChannel(channel.Data, channel.SampleCount * channel.Channels);
            }
            
            ApplyGain(channel.Data, options.Gain, channel.SampleCount * channel.Channels);
            ApplyLimiting(channel.Data, options.MaxLevel, channel.SampleCount * channel.Channels);
        }
        
        public void AddMicrophoneProcessing(AudioChannel channel, ProcessingOptions options)
        {
            // 麦克风音频处理实现
            if (options.EnableVoiceEnhancement)
            {
                VoiceEnhancer.ProcessChannel(channel.Data, channel.SampleCount);
            }
            
            if (options.EnableNoiseReduction)
            {
                NoiseReductionProcessor.ProcessMicrophoneAudio(channel.Data, channel.SampleCount);
            }
            
            ApplyGain(channel.Data, options.Gain * options.VoiceBoost, channel.SampleCount);
        }
        
        private void ApplyGain(float[] data, float gain, int length)
        {
            for (int i = 0; i < length; i++)
            {
                data[i] *= gain;
            }
        }
        
        private void ApplyLimiting(float[] data, float limit, int length)
        {
            for (int i = 0; i < length; i++)
            {
                data[i] = Math.Max(-limit, Math.Min(limit, data[i]));
            }
        }
    }

    // 混音总线
    public class AudioMixingBus : IDisposable
    {
        private float[] mixBuffer;
        
        public AudioMixingBus()
        {
            mixBuffer = new float[8192]; // 最大混音缓冲区
        }
        
        public float[] MixChannels(AudioChannel systemChannel, AudioChannel micChannel, MixingOptions options)
        {
            int outputSamples = Math.Max(systemChannel.SampleCount, micChannel.SampleCount);
            if (outputSamples == 0) return Array.Empty<float>();
            
            // 确保输出缓冲区足够大
            int outputLength = outputSamples * 2; // 立体声
            if (mixBuffer.Length < outputLength)
            {
                mixBuffer = new float[outputLength];
            }
            else
            {
                Array.Clear(mixBuffer, 0, outputLength);
            }
            
            // 智能混音算法
            for (int i = 0; i < outputSamples; i++)
            {
                float systemLeft = 0f, systemRight = 0f;
                float micValue = 0f;
                
                // 获取系统音频
                if (i < systemChannel.SampleCount)
                {
                    if (systemChannel.Channels == 1)
                    {
                        systemLeft = systemRight = systemChannel.Data[i];
                    }
                    else
                    {
                        int idx = i * 2;
                        systemLeft = systemChannel.Data[idx];
                        systemRight = systemChannel.Data[idx + 1];
                    }
                }
                
                // 获取麦克风音频
                if (i < micChannel.SampleCount)
                {
                    micValue = micChannel.Data[i];
                }
                
                // 智能混音 - 增强版算法
                if (options.EnableSmartMixing)
                {
                    float micLevel = Math.Abs(micValue);
                    float systemLevel = Math.Max(Math.Abs(systemLeft), Math.Abs(systemRight));
                    
                    // 计算短期能量（使用滑动窗口）
                    float micEnergy = micLevel * micLevel;
                    float systemEnergy = systemLevel * systemLevel;
                    
                    // 动态语音检测和平衡
                    if (micLevel > 0.08f) // 提高语音检测阈值
                    {
                        // 根据语音强度动态调整系统音频
                        float voiceStrength = Math.Min(1.0f, micLevel * 8.0f);
                        float dynamicReduction = 0.85f * voiceStrength; // 更强的动态抑制
                        
                        // 使用平滑的衰减曲线
                        float smoothFactor = (float)Math.Pow(1.0f - dynamicReduction, 1.5);
                        systemLeft *= smoothFactor;
                        systemRight *= smoothFactor;
                        
                        // 增强语音清晰度
                        float voiceBoost = 1.0f + voiceStrength * 0.4f;
                        micValue *= voiceBoost;
                    }
                    else if (micLevel > 0.02f) // 轻微语音活动
                    {
                        // 温和的系统音频衰减
                        float reduction = micLevel * 5.0f;
                        systemLeft *= (1.0f - reduction * 0.3f);
                        systemRight *= (1.0f - reduction * 0.3f);
                    }
                    
                    // 高级系统音频限制
                    if (systemLevel > 0.2f) // 更低的限制阈值
                    {
                        // 使用软限制曲线
                        float excess = systemLevel - 0.2f;
                        float compressionRatio = 1.0f / (1.0f + excess * 10.0f);
                        systemLeft *= compressionRatio;
                        systemRight *= compressionRatio;
                    }
                    
                    // 防止混音后的削波
                    float totalLevel = Math.Abs(systemLeft + micValue) + Math.Abs(systemRight + micValue);
                    if (totalLevel > 1.8f)
                    {
                        float scaleFactor = 1.8f / totalLevel;
                        systemLeft *= scaleFactor;
                        systemRight *= scaleFactor;
                        micValue *= scaleFactor;
                    }
                }
                
                // 混合到输出
                mixBuffer[i * 2] = systemLeft + micValue;
                mixBuffer[i * 2 + 1] = systemRight + micValue;
            }
            
            // 应用动态压缩
            if (options.EnableCompression)
            {
                DynamicsProcessor.ApplyCompression(mixBuffer, outputLength, 
                    options.CompressionThreshold, options.CompressionRatio);
            }
            
            // 创建输出数组
            float[] result = new float[outputLength];
            Array.Copy(mixBuffer, result, outputLength);
            return result;
        }
        
        public void Reset()
        {
            if (mixBuffer != null)
            {
                Array.Clear(mixBuffer, 0, mixBuffer.Length);
            }
        }
        
        public void Dispose()
        {
            mixBuffer = null;
        }
    }

    // 辅助处理器类
    public static class NoiseReductionProcessor
    {
        private static readonly float[] noiseSpectrum = new float[512];
        private static int noiseProfileFrames = 0;
        
        public static void ProcessSystemAudio(float[] data, int length)
        {
            // 更高级的系统音频降噪 - 针对电磁干扰和底噪
            const float baseThreshold = 0.0025f;  // 更低的阈值，保留更多细节
            const float maxReduction = 0.85f;     // 更强的降噪
            const float smoothing = 0.15f;        // 平滑过渡
            
            // 自适应噪声门
            float rms = CalculateRMS(data, length);
            float adaptiveThreshold = Math.Max(baseThreshold, rms * 0.05f);
            
            // 多阶段降噪
            for (int i = 0; i < length; i++)
            {
                float sample = data[i];
                float absSample = Math.Abs(sample);
                
                // 第一阶段：硬噪声门
                if (absSample < adaptiveThreshold * 0.5f)
                {
                    data[i] = 0; // 完全消除极低电平噪声
                }
                // 第二阶段：软过渡区
                else if (absSample < adaptiveThreshold * 2f)
                {
                    // 使用更平滑的过渡曲线
                    float normalizedLevel = (absSample - adaptiveThreshold * 0.5f) / (adaptiveThreshold * 1.5f);
                    float reduction = maxReduction * (float)Math.Pow(1 - normalizedLevel, 2);
                    data[i] = sample * (1 - reduction);
                }
                // 第三阶段：轻微降噪
                else if (absSample < adaptiveThreshold * 4f)
                {
                    float reduction = maxReduction * 0.2f * (1 - (absSample - adaptiveThreshold * 2f) / (adaptiveThreshold * 2f));
                    data[i] = sample * (1 - reduction);
                }
                
                // 应用平滑滤波减少突变
                if (i > 0)
                {
                    data[i] = data[i] * (1 - smoothing) + data[i - 1] * smoothing;
                }
            }
        }
        
        public static void ProcessMicrophoneAudio(float[] data, int length)
        {
            // 智能语音降噪 - 保留语音，去除背景噪音
            const float voiceThreshold = 0.001f;  // 更低的阈值以保留微弱语音
            const float maxReduction = 0.4f;      // 温和的降噪以保护语音
            
            // 检测语音活动
            bool voiceDetected = DetectVoiceActivity(data, length);
            float adaptiveReduction = voiceDetected ? maxReduction * 0.5f : maxReduction;
            
            for (int i = 0; i < length; i++)
            {
                float sample = data[i];
                float absSample = Math.Abs(sample);
                
                if (absSample < voiceThreshold)
                {
                    // 对极低电平应用降噪
                    data[i] = sample * (1 - adaptiveReduction);
                }
                else if (absSample < voiceThreshold * 3f && !voiceDetected)
                {
                    // 无语音时加强降噪
                    float factor = (absSample - voiceThreshold) / (voiceThreshold * 2f);
                    data[i] = sample * (1 - adaptiveReduction * (1 - factor * factor));
                }
            }
        }
        
        private static float CalculateRMS(float[] data, int length)
        {
            float sum = 0;
            for (int i = 0; i < length; i++)
            {
                sum += data[i] * data[i];
            }
            return (float)Math.Sqrt(sum / length);
        }
        
        private static bool DetectVoiceActivity(float[] data, int length)
        {
            // 简单的语音活动检测
            float energy = CalculateRMS(data, length);
            int zeroCrossings = 0;
            
            for (int i = 1; i < length; i++)
            {
                if (Math.Sign(data[i]) != Math.Sign(data[i - 1]))
                {
                    zeroCrossings++;
                }
            }
            
            float zeroCrossingRate = (float)zeroCrossings / length;
            
            // 语音特征：中等能量，适中的过零率
            return energy > 0.01f && zeroCrossingRate > 0.05f && zeroCrossingRate < 0.5f;
        }
    }

    public class SpectralGate
    {
        private readonly int sampleRate;
        
        public SpectralGate(int sampleRate)
        {
            this.sampleRate = sampleRate;
        }
        
        public float[] Process(float[] input)
        {
            // 频谱门控实现
            return input; // 简化版本
        }
        
        public static void ProcessChannel(float[] data, int length)
        {
            // 静态处理方法
            const float gateThreshold = 0.003f;
            
            for (int i = 0; i < length; i++)
            {
                if (Math.Abs(data[i]) < gateThreshold)
                {
                    data[i] = 0f;
                }
            }
        }
        
        public void Reset()
        {
            // 重置状态
        }
    }

    public class AdaptiveFilter
    {
        public float[] RemoveElectromagneticInterference(float[] input, int channels)
        {
            // 电磁干扰消除
            return input; // 简化版本
        }
        
        public void Reset()
        {
            // 重置状态
        }
    }

    public static class DynamicsProcessor
    {
        public static void ApplyCompression(float[] data, int length, float threshold, float ratio)
        {
            for (int i = 0; i < length; i++)
            {
                float sample = data[i];
                float absSample = Math.Abs(sample);
                
                if (absSample > threshold)
                {
                    float excess = absSample - threshold;
                    float compressedExcess = excess / ratio;
                    float newLevel = threshold + compressedExcess;
                    data[i] = sample * (newLevel / absSample);
                }
            }
        }
        
        public static float[] ApplyLimiting(float[] input, float limit)
        {
            float[] output = new float[input.Length];
            
            for (int i = 0; i < input.Length; i++)
            {
                float sample = input[i];
                float absSample = Math.Abs(sample);
                
                if (absSample > limit)
                {
                    output[i] = sample * (limit / absSample);
                }
                else
                {
                    output[i] = sample;
                }
            }
            
            return output;
        }
    }

    public class VoiceEnhancer
    {
        public float[] Process(float[] input)
        {
            // 语音增强实现
            return input; // 简化版本
        }
        
        public static void ProcessChannel(float[] data, int length)
        {
            // 静态处理方法
            const float voiceBoost = 1.2f;
            
            for (int i = 0; i < length; i++)
            {
                float sample = data[i];
                float absSample = Math.Abs(sample);
                
                // 语音频段增强
                if (absSample > 0.05f && absSample < 0.6f)
                {
                    data[i] = sample * voiceBoost;
                }
            }
        }
        
        public void Reset()
        {
            // 重置状态
        }
    }

    public static class HighQualityResampler
    {
        public static float[] Resample(float[] input, int fromRate, int toRate, int channels)
        {
            if (fromRate == toRate) return input;
            
            double ratio = (double)toRate / fromRate;
            int outputLength = (int)(input.Length * ratio);
            float[] output = new float[outputLength];
            
            // Lanczos重采样算法
            for (int i = 0; i < outputLength; i++)
            {
                double sourceIndex = i / ratio;
                output[i] = LanczosInterpolate(input, sourceIndex, 3);
            }
            
            return output;
        }
        
        private static float LanczosInterpolate(float[] input, double index, int a)
        {
            int baseIndex = (int)Math.Floor(index);
            double fraction = index - baseIndex;
            
            float sum = 0f;
            float weightSum = 0f;
            
            for (int i = -a + 1; i <= a; i++)
            {
                int sampleIndex = baseIndex + i;
                if (sampleIndex >= 0 && sampleIndex < input.Length)
                {
                    double x = i - fraction;
                    double weight = LanczosKernel(x, a);
                    sum += (float)(input[sampleIndex] * weight);
                    weightSum += (float)weight;
                }
            }
            
            return weightSum > 0 ? sum / weightSum : 0f;
        }
        
        private static double LanczosKernel(double x, int a)
        {
            if (x == 0) return 1.0;
            if (Math.Abs(x) >= a) return 0.0;
            
            double pix = Math.PI * x;
            double pixa = pix / a;
            return Math.Sin(pix) / pix * Math.Sin(pixa) / pixa;
        }
    }
} 